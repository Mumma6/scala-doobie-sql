import cats.effect.IOApp
import cats.effect.{ExitCode, IO}
import doobie.util.transactor.Transactor
import doobie.implicits._
import doobie.util.update._

// To run in watch mode, type sbt. then ~run
// to simply run. sbt "runMain Main"

// Tutorial https://www.youtube.com/watch?v=9xgOQh-Ppao&ab_channel=RocktheJVM

object Main extends IOApp {

  case class Actor(id: Int, name: String)
  case class Movie(
      id: String,
      title: String,
      year: Int,
      actors: List[String],
      director: String
  )

  implicit class Debugger[A](io: IO[A]) {
    def debug: IO[A] = io.map { a =>
      println(s"[${Thread.currentThread().getName()}] $a")
      a
    }
  }

  val xa: Transactor[IO] = Transactor.fromDriverManager[IO](
    "org.postgresql.Driver",
    "jdbc:postgresql://localhost/myimdb", // Use localhost and your local database name
    "postgres", // Your local PostgreSQL username
    "123" // Your local PostgreSQL password
  )

  def findAllActorNames: IO[List[String]] = {
    val query = sql"select name from actors".query[String]
    val action = query.to[List]
    action.transact(xa)
  }

  def findActorById(id: Int): IO[Actor] = {
    val query = sql"select id, name from actors where id=$id".query[Actor]
    val action = query.unique // .option
    action.transact(xa)
  }

  // Fragments
  def findActorsByInital(letter: String): IO[List[Actor]] = {
    val selectPart = fr"select id, name"
    val fromPart = fr"from actors"
    val wherePart = fr"where LEFT(name, 1) = $letter"

    val statement = selectPart ++ fromPart ++ wherePart
    statement.query[Actor].stream.compile.toList.transact(xa)
  }

  // Update
  def saveActor(id: Int, name: String): IO[Int] = {
    val query = sql"insert into actors (id, name) values ($id, $name)"
    query.update.run.transact(xa)
  }

  def saveActorV2(id: Int, name: String): IO[Int] = {
    val queryString = "insert into actors (id, name) values (?, ?)"
    Update[Actor](queryString).run(Actor(id, name)).transact(xa)
  }

  // autogeneratedIds
  def saveActorAutoGenerated(name: String): IO[Int] = {
    sql"insert into actors (name) values ($name)".update
      .withUniqueGeneratedKeys[Int]("id")
      .transact(xa)
  }

  // update/insert many
  def saveManyActors(actorNames: List[String]): IO[List[Actor]] = {
    val insertStatment = "insert into actors (name) values (?)"
    val actiorn = Update[String](insertStatment)
      .updateManyWithGeneratedKeys[Actor]("id", "name")(actorNames)

    actiorn.compile.toList.transact(xa)
  }

  def run(args: List[String]): IO[ExitCode] =
    saveActorV2(10, "Mary").debug.as(ExitCode.Success)
}
